# 객체

## 1. 객체지향 언어

- 객체지향 언어란?
  현실 세계는 사물이나 개념처럼 독립되고 구분되는 각각의 객체로 이루어져 있으며, 발생하는 모든 사건들은 객체간의 상호작용이다.
  이 개념을 컴퓨터로 옮겨 놓아 만들어낸 것이 객체지향 언어이다.
- Java 에서 객체란?
  클래스에 정의된 내용대로 new 연산자를 통해 메모리 영역에 생성된 것

**클래스**

- 객체의 특성에 대한 정의를 한 것으로 캡슐화를 통해 기능을 포함한 개념
- 사물이나 개념의 공통 요소를 추상화(abstraction)하여 정의함

**추상화**

- 유연성을 확보하기 위해 구체적인 것은 제거한다는 의미
- 프로그램에서 필요한 공통점을 추출하고, 불필요한 공통점을 제거하는 과정

**객체**

- 현실에 존재하는 독립적이면서 하나로 취급되는 사물이나 개념
- 객체 지향 언어에서 클래스에 정의된 내용대로 메모리에 할당된 결과물(Object) 지칭

<img src=".\image\Java07_객체_01객체.png" alt="Java07_객체_01객체" style="zoom:67%;" />

- 객체의 할당 : new 연산자와 생성잘르 사용하여 객체를 생성하면 heap 메모리 공간에 서로 다른 자료형의 데이터가 연속으로 나열/할당된 객체공간이 만들어진다. 이를 인스턴스(instance)라고 한다.`ex) Student s = new Student();`

<img src=".\image\Java07_객체_01객체할당.png" alt="Java07_객체_01객체할당" style="zoom:67%;" />

**객체 지향 3대 특징**

1. 캡슐화(Encapsulation)
2. 상속(Inheritance)
3. 다형성(Polymorphism)

**캡슐화**

- 추상화를 통해 정리된 데이터들과 기능을 하나로 묶어 관리하는 기법

  클래스의 가장 중요한 목적인 데이터의 접근제한을 원칠으로 하여 클래스 외부에서 데이터의 직접 접근을 막고, 대신 데이터를 처리하는 함수들을 클래스 내부에 작성하는 방법을 캡슐화 라고 함

- 캡슐화의 원칙

  1. 클래스의 멤버 변수에 대한 접근 권한은 private을 원칙으로 한다.
  2. 클래스의 멤버 변수에 대한 연산처리를 목적으로 하는 함수들을 클래스 내부에 작성한다.
  3. 멤버 함수는 클래스 밖에서 접근할 수 있도록 public으로 설정한다.

## 2. 필드

> **객체의 고유 데이터, 부품 객체, 상태 정보**를 저장하는 곳
> 선언된 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않는다.
> 변수는 생성자와 메서드 내에서만 사용되고, 생성자와 메서드가 실행 종료되면 자동 소멸된다.
> 필드는 생성자와 메서드 전체에서 사용되며, 객체가 소멸되지 않는 한 객체와 함께 공존한다.

## 3. 생성자(Constructor)

> 생성자란 객체가 new 연산자를 통해 Heap 메모리 영역에 할당될 때 객체 안에서 만들어지는 필드의 **초기화**를 담당한다.
> 생성자는 일종의 메서드로 전달된 초기값을 받아서 객체의 필드에 기록한다.

- 생성차 규칙
  생성자의 선언은 메서드 선언과 유사하나 반환값이 없다.
  **생성자명은 클래스명과 똑같이 지정해 줘야 한다.**

- 생성자 표현식

  - 기본생성자 : `[접근제한자] 클래스명() {}`

    \- 작성하지 않은 경우, 클래스 사용시 JVM이 자동으로 기본 생성자를 생성해준다.

  - 매개변수 생성자 : `[접근제한자] 클래스명([매개변수]) {this.필드명 = 매개변수;}`

    \- 객체 생성시 전달받은 값으로 객체를 초기화 하기 위해 사용한다.

    \- 매개변수 생성자 작성 시 JVM이 기본 생성자를 자동으로 생성해주지 않음

    \- 상속에서 사용 시 반드시 기본 생성자를 작성해야 한다.

    \- 오버로딩을 이용하여 작성한다.

**오버로딩**

- 오버로딩이란 한 클래스 내에 동일한 이름의 메서드를 여러 개 작성하는 기법

- 오버로딩 조건

  \- 메서드 이름이 같아야 한다.

  \- 매개변수의 개수 또는 타입이 같아야 한다.

  \- @Override 선언

**this**

- 모든 인스턴스의 메서드에 숨겨진 채 존재하는 레퍼런스로, 할당된 객체를 가리킨다.

- 함수 실행 시 전달되는 객체의 주소를 자동으로 받는다.

- this()는 같은 클래스의 다른 생성자를 호출할 때 사용한다.

  ```java
  // this() 사용 예시
  public class Academy{
      private int age;
      private String name;
      public Academy(){ // 생성자 내부
          this(20,"김철수") // 클래스의 다른 생성자 호출
      }
      public Academy(int age, String name) {
          this.age = age;  this.name = name;
      }
  }
  ```

## 4. 메서드(Method)

> 객체의 **동작**에 해당하는 블록
> 메서드란 수학의 함수와 비슷하며 호출을 통해 사용한다. 전달 값이 없는 상태로 호출을 하거나 어떤 값을 전달하여 호출을 하며, 함수 내에 작성된 연산을 수행한다.
> 수행 후 반환 값/결과 값은 있거나 없을 수 있다.

- 메서드 표현식
  `[접근제한자] [예약어] 반환형 메서드명([매개변수]){}`

## 5. Package & import

- 소스파일 구성 순서
  1. package 문
  2. import 문
  3. 클래스 선언

**패키지(package)란**

> 서로 관련된 클래스 혹은 인터페이스의 묶음
> 많은 클래스들을 체계적으로 관리하기 위해 이용

- 패키지는 클래스를 유일하게 만들어준느 식별자 역할을 한다.
- 클래스의 전체 이름은 "패키지명 + 클래스명" 이다.

패키지 선언

1. 숫자로 시작해서는 안되며, '_' 와 '$'를 제외한 특수문자 사용 불가
2. java 로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용하면 안됨
3. 모두 소문자로 작선하는 것이 관례

**import문**

- 다른 패키지에 속하는 클래스를 사용하기 위해 이용하며, 사용할 클래스가 속한 패키지를 지정하는 데 사용

- import 문으로 지정된 패키지의 **하위 패키지는 import 대상이 아니다**

  ```java
  import com.mycompany.*;
  import com.mycompany.project.*;
  ```

- 이름이 같은 클래스가 속한 두 패키지를 import 할 때는 클래스 앞에 패키지 명을 붙여 구분하여야 함

  ```java
  import java.util.Date;
  import java.sql.Date;
  public class ImportTest{
      public static void main(String[] args) {
          java.util.Date today = new java.util.Date();
      }
  }
  ```

  
